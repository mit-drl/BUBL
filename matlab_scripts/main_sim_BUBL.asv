%{
    Yaw Simulation for BUBL
    Author: Guillermo D. Mendoza

    Dynamics Equation:
        Mv_dot + C(v)v + D(v)v + g(eta) = tau

        Where:
            - v is the velocity of the robot
            - M is the inertia matrix
            - D is the hydrodynamic drag
            - g is the gravitational and buoyancy forces (restoring forces)
            - tau is the control forces and torques
            - eta is the state vector of the positions of the robot in the
            intertial frame

    Assumptions:
        - Coriolis Force can be neglected due to slow velocity of robot
          (~0.3m/s)
        - Restoring force has not influence on the motion of surge, sway, heave
          and yaw (therefore we can neglect g(eta)

    From our assumptions the equation becomes:
        Mv_dot + D(v)v = tau

%}

% Define Variables:

m = 0.1200; % mass of robot (kg)
R = 0.032; % radius of robot (m)
C_d = 0.5; % approximate value (Reynolds number for spherical body)

rho_w = 997; % density of water (kg/m^3)
mu = 10^(-3); % fluid viscosity (Pa)

a = 20; % degree selected to provide minimum sufficient dive thrust
alpha = 0.024; % moment arm for the fluid jets (m)

m_a = 2/3 * pi * R^3 * rho_w; % added mass of fluid interaction
I_aa = 2/5 * m * R^2; % moment of intertia of robot

syms v_x v_y v_z v_dot % define symbolic v for velocity to find D(V) matrix

M = [(m+m_a).* eye(3) ,zeros(3); zeros(3), eye(3) .* I_aa];
D = [(-1/2 * rho_w * C_d * pi * R^2) * [v_x, 0, 0; 0, v_y, 0; 0,v_z, 0] * eye(3), zeros(3);
    zeros(3), (-8*pi*R^3*mu)*eye(3)];

syms x y z phi theta psi
syms x_dot y_dot z_dot phi_dot theta_dot psi_dot

R = [cos(psi) * cos(theta), sin(psi)*cos(theta), -sin(theta);
    -sin(psi) * cos(phi) + cos(psi) * sin(theta)*sin(phi), cos(psi) * cos(phi) + sin(psi) * sin(theta) * sin(phi), sin(phi) * cos(theta);
    sin(psi) * sin(phi) + cos(psi) * sin(theta) * cos(phi), -cos(psi) * sin(phi) + sin(psi) * sin(theta) * cos(phi), cos(phi) * cos(theta)];

J = [1, 0, -sin(theta); 
     0, cos(phi), cos(theta) * sin(phi);
     0, -sin(phi), cos(theta) * cos(phi)];

eta = [x_dot; y_dot; z_dot; phi_dot; theta_dot; psi_dot];

v_vector = [R, zeros(3); zeros(3), J] * eta;

syms x_d_dot y_d_dot z_d_dot phi_d_dot theta_d_dot psi_d_dot

v_dot_vector = [x_d_dot; y_d_dot; z_d_dot; phi_d_dot; theta_d_dot; psi_d_dot];

eqn = M * v_dot_vector + D * v_vector;
eqn = subs(eqn, {v_x, v_y, v_z}, {v_vector(1), v_vector(2), v_vector(3)});
eqn = subs(eqn, {phi, theta, phi_dot, theta_dot, phi_d_dot, theta_d_dot}, {0,0,0,0,0,0});

yaw_eqn = eqn(6);

sympref('FloatingPointOutput',true);

syms s

psi_d_dot_laplace = s^2;   
psi_dot_laplace = s;    

yaw_eqn_laplace = subs(yaw_eqn, {psi_d_dot, psi_dot}, {psi_d_dot_laplace, psi_dot_laplace})


num = [1]

sym2poly(yaw_eqn_laplace)
denom = coeffs(yaw_eqn_laplace, s, 'All')
